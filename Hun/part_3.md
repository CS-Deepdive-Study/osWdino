# ch 6

## 배경 지식

### race condition (경쟁 상황)

동시에 여러 프로세스가 동일한 자료에 접근, 조작

실행 결과가 특정 순서에 의존

### critical-section (임계 구역)

임계구역에는 한번에 하나의 프로세스만이 접근하여 갱신한다

여기에는 3가지 문제가 존재

1) 상호 배제

어떤 프로세스가 임계구역에 진입하면 다른 프로세스는 진입 불가
2) 진행

임계구역에 프로세스가 없고, 진입하려는 프로세스가 존재하면 나머지 구역에서 실행중이지 않은 프로세스들이 누가 임계구역에 진입할지 결정
3) 한정된 대기

프로세스가 진입 요청 한 이후 다른 프로세스들의 진입이 허용되는 횟수에 제한이 있어야 한다

### 해결법

1. 동기화를 위한 hw지원

   1) 메모리 장벽
   
  메모리 모델의 2가지 범주

    강한 순서 : 메모리 변경 결과가 다른 프로세스에 바로 보임
    약한 순서 : 메모리 변경 결과가 다른 프로세스에 바로 보이지 않음
    -> 변경된 내용을 메모리에 전파하는 memory barrier, memory fence 등의 명령어 필요
    적재 또는 저장 작업이 수행 되기 전에 저장 작업이 메모리에서 완료되어 다른 프로세스에 보이게 함

   1) hw 명령어
   
    test_and_set : 원자적으로 실행 됨, lock
    compare_and_swap : 원자적으로 실행 됨, lock값이 expect와 일치해야 수행


   2) 원자적 변수

    변수에 대한 원자적 연산을 제공
    CAS 이용해 구현
    경쟁 조건 해결 X

2. mutex lock


    프로세스는 임계구역 진입 전에 lock을 획득해야 한다
    빠져나오기 전에 lock을 반환해야 한다
    lock을 획득하기 전까지는 block
    lock을 acquire, release하는 연산 모두 원자적으로 실행되어야 한다
    이는 CAS를 이용해 구현한다
    busy-wating 필요

3. 세마 포어

구현 2가지 방법

1) busy-wating
    

    이때 세마포어는 자원의 수를 의미

4) block


    이때 세마포어의 절대값은 기다리는 프로세스의 수를 의미

4. 모니터

5. 라이브 니스

프로세스가 실행 생명 주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야하는 일련의 속성

라이브니스 실패로 이어 질 수 있는 2가지 상황

1) 교착 상태
2) 우선순위 역전