#ch 9

### 주소 바인딩

한 주소 공간에서 다른 주소 공간으로 맵핑, 그 시점에 따라 3가지로 구분

1. 컴파일 시간

프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 알 수 있으면 컴파일러가 절대 코드를 생성, 위치가 변경되면 다시 컴파일

3. 적재 시간 바인딩

컴파일러가 재배치 가능한 코드를 생성 바인딩은 메모리에 적재될 때 이뤄짐

3. 런타임 바인딩

만약 프로세스가 실행 주 메모리의 어떤 세그먼테에서 다른 세그먼트로 이동 가능하면 바인딩이 실행 시간까지 허용된 것, HW의 지원 필요

### 논리 주소와 물리 주소

논리 주소 : cpu가 생성하는 주소

물리 주소 : 메모리가 취급하는 주소

이 둘 사이의 변환은 mmu(HW)책임

### 동적 전재, dynamic loading

동적 적재에서는 필요한 부분만 mem에 적재

mem에 적재되지 않은 루틴을 호출하면 relocatable linking loader가 필요한 부분을 적재하고 table에 기록

os의 특별한 지원 필요 없다

### DLL, 동적 연결 라이브러리

실행 시점에 사용자 프로그램과 연결되는 시스템 라이브러리

실행 가능 이미지의 사이즈를 줄일 수 있고, mem에 DLL이 올라가 있으면 여러 프로세스에서 공유 가능

OS 지원 필요

### 메모리 보호

base, limit 레지스터를 이용하여 메모리를 보호

### 메모리 할당

메모리 할당의 쉬운 예는 가변 크기 파티션에 할당하는 상황

3가지 할당 전략이 존재한다

1. 최초 적합

할당 가능한 첫번째 파티션

4. 최적 적합

할당 가능한 가장 작은 파티션

5. 최악 적합

할당 가능한 가장 큰 파티

### 단편화

외부 : 조각 난 부분을 합치면 충분하지만 분산되어 있어 할당 못하는 경

내부 : 필요한 용량보다 더 많이 할당 한 경우

해결 2가지

1. 압축, compaction

메모리 내용을 한 곳으로 몰기

2. 페이징

프로세스의 논리 주소 공간을 비연속적인 공간으로 나누어 할당