# CH02. 운영체제 구조

# 운영체제 서비스

## 프로그래머를 위한 서비스

- 사용자 인터페이스 - GUI, CLI
- 프로그램 수행
- 입출력 연산 수단 제공
- 파일 시스템 조작
- 통신 - 공유 메모리, 메시지 전달 등
- 오류 탐지 - 디버깅 설비 필요

## 시스템 효율적 동작을 위한 서비스

- 자원 할당 - 다수의 프로세스/작업 실행 시 각각 자원 할당 필요
- 로깅 - 컴퓨터 자원 사용 추적
- 보호 및 보안 - 시스템 자원에 대한 접근 통제, 인증

# 사용자와 운영체제 인터페이스

## 명령 인터프리터

- Shell이라고 부름
- 사용자의 명령을 가져와서 그것을 수행
- 구현 방식
    - 명령 인터프리터 자체에 명령을 실행할 코드가 있는 경우
    - 시스템 프로그램에 의해 명령을 구현하는 경우 - 유닉스 채택

## GUI

- 사용자 친화적

## 터치스크린

- 모바일 시스템에 주로 사용

## 인터페이스 선택

- 사용자의 선호에 달려 있음
- 시스템 관리자/파워 유저는 CLI가 효율적, 셸 스크립트도 활용 가능
- 일반적인 사용자는 GUI 사용
- 모바일 사용자는 터치스크린 사용

# 시스템 콜

- 커널 모드에서 사용 가능한 서비스에 대한 인터페이스를 제공
- 일반적으로 C/C++언어로 작성된 함수 형태로 제공
- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하게 됨 → API에 따라 프로그램을 설계함으로써 매개변수, 반환값을 이용하여 함수의 사용이 가능
- API를 사용하는 이유
    - 프로그램의 호환성 - 같은 API를 지원하면 어느 시스템이건 컴파일/실행 가능
    - 실제 시스템 콜은 더 자세한 명세가 필요하므로 API가 더 쉬움
    - 대부분의 API는 사실상 시스템 콜과 유사함
- 런타임 환경
    - 특정 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 및 연계 소프트웨어를 모두 통틀어 지칭
    - 시스템 콜 인터페이스 제공
- 운영체제에게 매개변수를 전달하는 방법
    - 레지스터를 통해 전달
    - 레지스터보다 많은 경우 메모리 내 블록/테이블에 저장하고 블록 주소를 통해 전달
    - 리눅스에서는 5개 이하일 때 레지스터를 쓰고, 5개가 넘으면 스택에 넣어서 전달
- 유형
    - 프로세스 제어
        - 실행, 제어 전환, 종료 등 수행 상태 제어
        - 공유 데이터를 위한 Lock 시스템 콜
    - 파일 조작
        - 파일 생성/삭제, 열기/닫기, 읽기/쓰기, 커서 위치 변경, 되감기
        - 파일 속성 획득, 속성 설정
        - 파일 이동/복사
    - 장치 관리
        - 장치 요청 - 독점적 사용 보장
        - 장치 릴리즈 - 사용 종료
        - 파일 형태로 장치 관리, 열기/닫기, 읽기/쓰기, 위치 변경 등 활용
        - 파일과 유사한 구조가 많아서 파일-장치 구조로 결합
    - 정보 유지
        - 현재 시간, 날짜 리턴
        - 메모리 덤프
        - 한 명령어 실행(single step) 모드를 활용하면 모든 명령 이후 트랩을 실행시켜 디버깅 가능
        - strace는 실행될 때마다 각 시스템 콜 나열해서 디버깅 해줌
        - time profile을 위한 정규 타이머 인터럽트(일정 시간마다 프로그램 카운터 값 기록)
        - 모든 프로세스 정보에 접근, 특정 프로세스 정보를 획득하고 설정
    - 통신
        - 호스트 이름, 프로세스 이름 가져오기
        - Open, Close
        - Accept, Wait for connection
        - 서버에서의 read_msg, write_msg
        - 공유 메모리 모델에서 공유 메모리 접근을 위한 create, attach
    - 보호
        - 권한 설정, 권한 가져오기
        - 허가된 유저, 불허된 유저 확인

# 시스템 서비스

- 시스템 유틸리티라고 부르기도 함, 프로그램 개발 및 실행을 위해 더 편리한 환경
- 종류
    - 파일 관리
    - 상태 정보
    - 파일 변경
    - 프로그래밍 언어 지원
    - 프로그램 적재/수행통신백그라운드 서비스

# 링커 & 로더

- 링커 - 오브젝트 파일을 하나의 바이너리 실행 파일로 결합
- 로더 - 바이너리 실행 파일을 메모리에 적재할 때 사용

# 크로스 플랫폼

- 방법
    1. 인터프리터 언어로 작성 후, 소스 프로그램의 각 라인을 읽고 해당 운영체제의 시스템 콜 호출.
    ex) Python, Ruby
    2. 가상 머신을 가진 언어로 작성. 로더, 바이트코드 검증기, 응용 프로그램을 가상 머신으로 적재. 
    ex) Java
    3. 컴파일러가 기기 및 운영체제 고유의 바이너리 파일 생성, 각 운영체제로 이식
    ex) POSIX API
- ABI - 아키텍처 수준의 API, 플랫폼 간 호환성 x

# 운영체제 빌딩과 부팅

- 운영체제 생성 순서
    1. 운영체제 소스 코드 작성
    2. 운영체제가 실행될 시스템의 운영체제를 구성
    3. 운영체제를 컴파일
    4. 운영체제를 설치
    5. 컴퓨터와 새 운영체제를 부팅
- 부팅 순서
    1. 부트스트랩 또는 부트 로더라는 프로그램이 커널의 위치를 찾음
    2. 커널이 메모리에 적재되며 시작
    3. 커널의 하드웨어 초기화
    4. 루트 파일 시스템 마운트