# CH05. CPU 스케줄링

# 스케줄링 개념

- 멀티프로그래밍 상황에서 다수의 프로세스를 메모리 내에 유지하면서 cpu를 바쁘게 유지하는 개념
- CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 갖게 하는 방법

## CPU-I/O 버스트 사이클

- 프로세스 실행은 CPU 실행과 I/O 대기 사이클로 이루어짐
- I/O 중심 프로그램은 짧은 CPU 타임, CPU 중심 프로그램은 긴 CPU 타임을 가짐

## CPU 스케줄러

- CPU가 아이들 상태가 되면, 준비 큐의 프로세스 중 하나를 선택해 실행
- 이때 선택하는 절차 - CPU 스케줄링, CPU 스케줄러가 프로세스를 선택

## 선점과 비선점

- CPU 스케줄링을 결정하는 상황
    1. 한 프로세스가 실행 상태에서 대기 상태로 전환(I/O 요청 또는 wait 호출 등)
    2. 프로세스가 실행 상태에서 준비 완료 상태로 전환(인터럽트 발생 등)
    3. 프로세스가 대기 상태에서 준비 완료 상태로 전환(I/O 종료 등)
    4. 프로세스 종료
- 1번, 4번 상황의 경우 새로운 프로세스가 반드시 선택되어야 함
    - 이때만 스케줄링이 발생할 경우 비선점 또는 협조적 스케줄링이라고 함
    - 비선점에서는 cpu에 프로세스가 할당되면 종료되거나 대기가 될때까지 점유
- 2번, 3번 상황에서는 선택의 여지가 있음
    - 이때는 선점 스케줄링이라고 함
    - 대부분의 최신 운영체제들이 선점 스케줄링 사용

### 선점 스케줄링

- 경쟁 조건을 초래할 수 있음
(ex. 두 프로세스가 자원을 공유하는 경우 데이터의 일관성이 깨질 수 있음)
- 커널 설계에 영향을 줌
    - 시스템 콜을 처리하는 동안 선점 프로세스로 인해 변경된다면? 문제 발생 가능
    - 운영체제 커널 역시 선점/비선점 두 가지 모두 가능
    - 비선점형 커널 - 시스템 콜이 완료되거나 커널 자료 변경을 단순히 기다림
    (설계는 간단하나 시간이 오래 걸려 실시간 컴퓨팅에는 좋지 않다)
    - 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위한 락 기법 사용(mutex 등)
- 인터럽트의 영향을 받는 코드는 반드시 보호받아야 함

## 디스패처

- CPU 코어의 제어를 스케줄러가 선택한 프로세스에 주는 모듈
- 해당 모듈이 하는 일
    - 한 프로세스에서 다른 프로세스로 문맥을 교환
    - 유저 모드로 전환
    - 프로그램을 다시 시작하기 위해 유저 프로그램의 적절한 위치로 점프
- 모든 프로세스의 컨텍스트 스위칭 시 호출, 최대한 빠르게 수행되는 게 좋음
- 컨텍스트 스위칭의 두 분류
    - 자발적 컨텍스트 스위칭 - 현재 사용 불가능한 자원 요청(I/O를 기다리며 블로킹 중)
    - 비자발적 컨텍스트 스위칭 - CPU를 빼앗겼을 때(타임 슬라이스 만료, 다른 프로세스에 선점)

# 스케줄링 기준

- 여러 기준이 존재할 수 있음
    - CPU 이용률 - 최대화
    - 처리량(단위 시간당 완료된 프로세스의 수) - 최대화
    - 총 처리 시간(준비 큐 대기 시간 + CPU 실행 시간 + I/O 시간) - 최소화
    - 대기 시간(준비 큐 대기 시간) - 최소화
    - 응답 시간(하나의 요청 이후 첫 번째 응답이 나올 때까지의 시간) - 최소화
- 대화식 시스템의 경우 응답 시간의 편차를 줄이는 것이 중요하다고 하지만, 그러한 스케줄링 알고리즘에 대한 연구는 전무함

# 스케줄링 알고리즘

- 코어가 하나뿐이라고 가정

## 선입선출 알고리즘(FCFS, FIFO)

- CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받음
- 알고리즘이 간단함
- 대기 시간이 길어질 수 있음
- 비선점 알고리즘

## 최단 작업 우선(SJF)

- 가장 짧은 업무를 우선으로 수행한다
- 최소의 평균 대기 시간을 가짐으로써 최적임을 증명할 수 있다
- 그러나 실질적으로는 CPU 사용 시간을 측정할 수 없기 때문에 구현할 수 없고, 근사한 방법을 사용할 수밖에 없음
- 선점, 비선점 두 가지 경우 모두 구현할 수 있다

## 라운드 로빈

- 선입 선출과 유사하지만, 프로세스 사이를 옮겨 다닐 수 있도록 선점 추가
- 시간 할당량, 타임 슬라이스라고 하는 단위 시간을 정의
- 시간 할당량만큼 원형 준비 큐를 순회한다
- 시간 할당량의 크기가 튜닝 포인트가 된다
- 시간 할당량이 문맥 교환 시간보다는 더 커야 한다

## 우선순위 스케줄링

- SJF도 일련의 우선순위 스케줄링 기법 중 하나이다.
- 우선 순위에 따라 스케줄링을 논의 - SJF는 CPU 버스트의 역이 우선 순위가 된다
- 무한 봉쇄 문제, 기아 상태 문제가 발생 가능
    - aging을 통하여 해결 가능
    - 라운드 로빈을 결합하여 해결 가능

## 다단계 큐 스케줄링

- 우선순위마다 별도의 큐를 갖게 해서 우선순위 + 라운드 로빈 구현
- 여러 개의 개별 큐로 분할하기 위해 사용하는 경우도 있음(포그라운드 + 백그라운드)
- 각 큐마다 별도의 자체 스케줄링 알고리즘이 존재할 수 있음

## 다단계 피드백 큐 스케줄링

- 여러 개의 큐가 있지만, 프로세스가 여러 큐 사이를 이동할 수 있음
- 어떤 프로세스가 CPU 시간을 너무 많이 사용하면 낮은 우선순위의 큐로 이동

# 스레드 스케줄링

- 유저 레벨 - 커널 레벨 스레드를 구분
- 유저 레벨 스레드는 스레드 라이브러리에 의해 관리되고 커널은 알 수 없긴 하지만,
CPU에서 실행되기 위해서는 결국 궁극적으로 커널 레벨 스레드에 매핑되어야 함